typedef struct
{
    u64 State;
    u64 Inc;
} pcg32_random_t;

internal u32
pcg32_random_r(pcg32_random_t *Generator)
{
	  u64 Oldstate = Generator->State;
	  // Advance internal state
	  Generator->State = Oldstate * 6364136223846793005ULL + (Generator->Inc | 1);
	  // Calculate output function (XSH RR), uses old state for max ILP
	  u32 xorshifted = ((Oldstate >> 18u) ^ Oldstate) >> 27u;
	  u32 rot = Oldstate >> 59u;

	  return (xorshifted >> rot) | (xorshifted << ((-rot) & 31));
}

internal u32
pcg32_boundedrand_r(pcg32_random_t *Generator, u32 Bound)
{
    // To avoid bias, we need to make the range of the RNG a multiple of
    // bound, which we do by dropping output less than a threshold.
    // A naive scheme to calculate the threshold would be to do
    //
    //     uint32_t threshold = 0x100000000ull % bound;
    //
    // but 64-bit div/mod is slower than 32-bit div/mod (especially on
    // 32-bit platforms).  In essence, we do
    //
    //     uint32_t threshold = (0x100000000ull-bound) % bound;
    //
    // because this version will calculate the same modulus, but the LHS
    // value is less than 2^32.

    u32 Threshold = -Bound % Bound;
    // Uniformity guarantees that this loop will terminate.  In practice, it
    // should usually terminate quickly; on average (assuming all bounds are
    // equally likely), 82.25% of the time, we can expect it to require just
    // one iteration.  In the worst case, someone passes a bound of 2^31 + 1
    // (i.e., 2147483649), which invalidates almost 50% of the range.  In 
    // practice, bounds are typically small and only a tiny amount of the range
    // is eliminated.
    for (;;)
    {
        u32 r = pcg32_random_r(Generator);
        if (r >= Threshold) return r % Bound;
    }
}

internal void
InitRandom32(pcg32_random_t *Generator, u64 InitState, u64 InitSeq)
{
	  Generator->State = 0U;
	  Generator->Inc = (InitSeq << 1u) | 1u;
	  pcg32_random_r(Generator);
	  Generator->State += InitState;
	  pcg32_random_r(Generator);
}

inline float
GetRandom(int x)
{
    x = (x << 13) ^ x;
    float Result = (1.0f - ((x * (x * x * 15731 + 789221) + 1376312589) & 2147483647) / 1073741824.0f);

    return Result;
}

static int32 Random_[] =
{
     764,   681,  -515,   -67,  -445,   781,   659,  -756,
     198,  -153,    89,  -440,   -72,   498,   628,  -956,
    -317,   210,   102,   138,  -694,   609,  -218,   -82,
     464,  -438,   636,   739,   -73,   223,  -543,   632,
      97,  -316,   573,  -128,   -60,   916,  -718,  -595,
    -518,   208,   862,   227,  -312,  -884,   810,  -229,
     525,  -546,   -28,  -405,  -650,   307,  -356,  -523,
     772,   434,    83,   558,   296,  -580,  -892,  -250,
     848,   178,   481,   459,  -267,   440,   645,  -908,
     -54,  -481,   819,  -259,  -364,   -92,   699,   879,
    -276,  -281,   946,   941,   532,  -596,   529,   -86,
     893,    62,  -122,   -74,   477,  -494,   546,   412,
    -878,  -490,   793,   109,   186,   319,   618,  -631,
     269,  -818,  -752,   744,   240,  -637,   964,   737,
     631,    43,  -591,   825,   944,   118,   963,  -348,
     728,  -434,  -408,   125,   697,  -919,   572,   466,
    -564,  -918,  -479,  -690,   541,   204,  -611,  -536,
      30,  -802,  -765,   265,    33,   485,   798,   909,
    -116,  -185,   823,   976,   -98,   104,  -965,  -253,
     843,   174,  -674,  -180,   484,  -902,  -261,    86,
     730,  -829,  -228,   346,  -252,  -501,  -234,   804,
     406,  -172,    13,   260,   258,    14,   230,  -951,
     211,   106,   599,   555,   936,  -913,  -584,   579,
      28,  -949,   479,   984,  -321,  -195,    32,   686,
    -576,  -613,   365,  -597,   241,    15,   542,   141,
    -150,   802,   837,   832,   967,  -457,  -436,    12,
    -468,   439,   970,   784,   901,   828,   187,   857,
     137,  -770,   913,  -852,    74,   162,   897,   283,
    -541,  -708,   694,  -901,  -161,    26,   355,  -556,
     423,  -726,   710,  -482,   720,  -512,    94,  -335,
      -3,  -399,   507,  -287,  -163,  -130,  -836,  -401,
     -19,   -84,   663,   279,   248,  -334,   -43,  -659,
     259,   -77,   404,  -326,    76,  -867,   499,  -784,
     849,   262,   -69,   979,  -740,   928,   671,   -58,
     687,  -737,  -467,   496,  -679,   473,  -848,  -722,
    -463,  -866,   917,   217,   900,  -544,  -873,   501,
    -814,  -131,   322,  -885,   700,   414,   203,   -59,
     907,  -992,  -723,  -773,  -313,    -2,  -538,  -368,
     380,   413,   250,   833,   969,   892,   625,   762,
    -410,  -411,   271,   826,   539,   -36,   156,   420,
     921,   -62,    49,  -922,  -849,   594,   112,   442,
     136,   955,  -497,  -823,   205,  -327,  -442,   994,
     621,  -653,  -248,  -886,  -614,  -592,    48,  -627,
    -141,    25,   -63,    47,   445,   212,  -322,    95,
    -203,   358,   698,  -201,   295,   -75,  -645,  -360,
    -233,  -215,   791,   920,   586,   233,  -944,  -213,
      -4,  -310,  -301,  -560,  -157,  -183,  -392,  -887,
    -634,  -937,  -142,  -767,   266,   123,   974,  -626,
    -418,   685,   105,  -535,   637,     1,  -762,   336,
     799,   -68,  -300,  -807,  -874,  -395,  -208,   377,
      71,   602,  -853,  -284,  -137,  -839,   613,  -589,
     782,   815,   889,   630,  -966,    38,   417,  -100,
     830,  -827,  -929,   601,   391,   684,  -739,   847,
     521,   367,  -508,   219,  -734,   474,  -623,  -132,
     842,  -803,  -464,    23,   408,   520,  -382,  -305,
    -367,  -296,  -931,   603,  -138,   553,   957,  -851,
     786,   421,   504,  -688,   951,   592,  -168,   712,
    -810,   234,  -761,   550,   760,  -193,  -210,  -862,
     678,  -563,  -551,   -14,   923,  -447,   235,  -731,
    -293,  -188,   331,   159,  -407,  -703,   956,   196,
    -275,  -615,  -280,  -190,  -478,   577,   704,  -469,
    -647,  -747,   339,   493,  -569,  -124,   702,   850,
       0,   502,  -427,   695,   126,  -552,  -143,  -453,
     713,   841,  -928,  -953,  -601,  -462,   662,  -994,
     415,  -249,  -175,   350,   648,   508,   394,  -725,
     270,   325,  -176,   374,  -948,   867,   818,  -129,
    -419,   902,   407,  -600,  -925,   318,   461,   654,
    -838,   968,  -638,   664,  -905,   633,   992,  -857,
     -96,   335,  -358,  -286,  -359,   766,  -345,  -812,
      55,   653,   866,  -699,   993,  -969,  -938,   777,
     947,   820,  -133,  -921,  -461,  -745,    -9,   -66,
     288,  -616,    58,  -444,   215,  -990,   926,  -545,
     468,  -506,   472,   779,  -165,   129,   894,  -397,
    -798,   252,  -567,  -421,   292,   647,   622,   860,
    -758,   657,  -989,    50,   139,   519,   517,   600,
     859,  -744,   164,  -236,   604,  -558,   401,   297,
     395,    99,   691,  -299,  -707,  -733,   725,  -424,
    -429,   605,   244,   478,  -899,   707,  -815,   -49,
    -202,  -746,    44,  -101,   316,   444,  -295,  -879,
    -166,  -156,   610,  -365,   679,  -572,  -861,   287,
    -378,    16,  -705,  -869,  -451,   929,   878,  -258,
    -952,    42,  -240,   362,  -817,   182,  -255,   869,
     854,   991,   155,  -474,  -272,  -960,   773,   977,
    -554,   780,   950,  -241,  -264,  -212,   -18,  -856,
    -471,   389,  -387,   282,  -231,   115,  -125,  -727,
    -216,   598,   385,  -262,  -537,   494,  -889,  -793,
     128,  -376,  -883,   471,   -35,  -230,   254,  -292,
     915,   -85,   -20,   242,  -377,   300,  -768,  -704,
      -8,   562,  -206,   436,   905,   548,   552,  -651,
     930,  -304,  -946,   -55,  -330,   315,  -721,   682,
    -480,   831,    59,    41,  -393,  -454,   455,  -121,
    -561,  -549,  -987,  -214,   -50,  -624,  -491,   931,
    -450,   811,    63,   834,    73,  -801,   497,  -619,
     276,  -211,   122,  -741,   -51,   328,  -877,  -822,
     803,  -297,  -774,   816,  -816,   303,  -926,   556,
     641,    40,   932,  -530,   403,   -94,   177,   311,
    -980,   298,   646,  -669,   812,    70,   906,   449,
     571,   426,  -779,   924,   742,  -174,  -606,  -973,
     337,   411,  -854,  -566,  -385,   140,    84,   982,
     792,     2,   -46,  -860,  -307,  -459,   101,   883,
     257,   304,  -553,  -539,   608,   688,   693,   131,
     585,   948,  -516,   565,   147,   705,    69,  -639,
     206,   -70,  -227,  -511,   165,  -607,   845,  -700,
    -524,  -686,   506,   617,  -209,   340,   152,   114,
    -308,   767,  -612,  -681,   676,   757,  -797,    18,
     660,  -361,  -742,  -959,  -420,  -164,  -764,   -93,
    -642,  -778,   453,   761,  -934,   864,   570,   289,
     751,  -830,   925,   280,   487,  -217,  -940,    60,
    -225,  -278,   -53,   216,   749,   640,   416,   668,
    -963,  -910,   858,   649,   168,  -573,   615,  -689,
     175,   896,  -118,  -648,   675,  -525,   890,   480,
    -808,   -30,   626,  -730,   285,  -769,    34,  -263,
    -363,  -127,  -126,  -672,  -759,  -425,  -340,  -331,
     201,  -636,   960,  -112,   989,   -78,   809,  -380,
    -169,  -283,   962,  -620,   567,  -986,   569,   200,
    -713,   107,  -575,   778,    45,  -492,   735,   990,
      82,   135,  -336,  -237,   643,  -151,     7,   -29,
     689,  -540,  -519,   224,  -687,   954,   373,   193,
    -391,   409,  -714,  -171,  -245,  -493,   665,   796,
    -439,  -932,  -811,   -13,  -528,  -763,  -820,  -682,
    -147,   376,   533,  -148,   -17,   560,  -379,  -720,
     352,   432,   476,  -706,   732,    53,   425,    68,
    -970,   545,  -510,   981,  -354,   202,  -754,   821,
      -6,  -483,  -402,   527,   306,   554,   -81,  -251,
     666,   775,  -120,   398,   758,  -890,   382,    22
};

global_variable pcg32_random_t RandomGenerator;
global_variable real32 RandomSequence[2064];

#define Random ((float)(pcg32_random_r(&RandomGenerator) % 100) / 100.0f)
#define Random01(Index) Abs((Random_[Index]/1000.0f))

inline float
WhiteNoise(float x)
{
    int ix = (int)x;
    //Range[int,0:1]
    float xMin = Random01(ix);
    float xMax = Random01(ix+1);
    float xfract = x - (float)ix;

    return Lerp(xMin, xMax, xfract);
}

inline float
SmoothNoise(float x, int Count)
{
    int xi = (int)x; 
    int xMin = xi;// % (int)(Count);
    float t = x - xi;
    int xMax = xMin + 1;//(xMin == (Count-1)) ? 0 : xMin+1;
    Assert(xMin < ArrayCount(RandomSequence))
    Assert(xMax < ArrayCount(RandomSequence))
    return Lerp(RandomSequence[xMin], RandomSequence[xMax], Smoothstep(t));
}